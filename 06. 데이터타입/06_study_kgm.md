# 📗챕터 정리
## 데이터 타입은 왜 필요한가?

```jsx
let score = 65;
```

개발자가 값을 변수에 할당할 때, 컴퓨터는 값을 저장하기 위해 메모리 공간을 확보한다.

이 과정에서 컴퓨터는 확보해야 할 메모리 공간의 크기를 계산하는데, 이것을 결정하는 것이 데이터 타입이다.

`score` 변수를 할당할 때, 컴퓨터는 값의 데이터 유형이 숫자 타입인 것을 확인하여 숫자 타입을 저장하기 위한 8바이트 크기의 공간을 먼저 확보하게 된다. 이 다음, 확보한 공간에 `65` 라는 값을 2진수로 저장하는 것이다.

변수를 참조할 때도 마찬가지로 먼저 참조된 변수 값의 타입이 숫자 타입임을 확인한 후, `score` 변수가 저장된 위치부터 8바이트 단위로 끊어서 읽어 들이게 된다.

만약 저장된 값은 숫자 타입이지만, 컴퓨터가 데이터 유형이 숫자 타입인 것을 확인할 수 없어 8바이트 단위가 아닌 다른 단위로 읽어 들인다면 저장된 값이 훼손될 수도 있는 것이다.

컴퓨터가 값을 해석할 때도 데이터 타입이 주요하게 작용한다.

`score` 변수의 값인 `65` 를 저장하기 위해 확보한 공간에는 값을 2진수로 저장한다고 했으니, 메모리 공간에는 `0100 0001` 가 저장되어 있다.

다시 `score` 변수를 참조할 때, 위 2진수를 숫자로 해석하면 `65` 이지만, 문자열로 해석하면 `A` 이다.

이 때 컴퓨터는 변수에 할당한 값의 데이터 타입이 숫자 타입임을 확인하고, 저장된 2진수를 `65` 라는 값으로 읽어 들일 수 있게 된다.

---

## JavaScript 데이터 타입의 종류

> **자바스크립트는 객체로 이루어진 언어로써, 모든 데이터 유형의 근본은 객체이다.**
> 
1. **숫자 타입 (Number) → [숫자/수학 객체](https://www.notion.so/Number-Math-0e993c03f9e547d8a8ef2b44c9226e6f?pvs=21)**
    - 정수(`10`), 실수(`10.12`), 음수(`-20`)
    - 2진수(`0b00010001`), 8진수(`0o101`), 16진수(`0x41`)
    - 산술 연산 불가(`NaN`)
        - 자바스크립트는 대소문자를 구별하기 때문에 `nan`, `Nan` 같이 입력하면 에러가 발생한다.
    - 양/음의 무한대(`+Infinity`, `-infinity`)
    - $2^{53}$-1 (9007199254740991) 보다 큰 값은 숫자형을 사용해 나타낼 수 없다.
2. **BigInt 타입**
    - ES11 버전에서 새로 추가된 데이터 타입이다.
    - BigInt 타입의 등장으로 자바스크립트에서 길이에 상관없이 매우 큰 정수를 저장할 수 있게 되었다.
    - 일반적으로 BigInt 타입은 사용될 일이 없지만, 암호 관련 작업 등 특수한 경우에는 사용될 수 있다.
    - 숫자 값의 끝에 n을 붙이면 BigInt 타입으로 저장된다.
        
        ```jsx
        // 끝에 'n'이 붙으면 BigInt형 자료
        const bigInt = 1234567890123456789012345678901234567890n;
        ```
        
3. **문자열 타입 (String) → [문자열 객체](https://www.notion.so/String-4064768d5ada46ee8e1f795639ae42d4?pvs=21)**
    - 텍스트 데이터를 표현할 때 사용한다.
    - 문자열은 작은 따옴표(`' '`), 큰 따옴표(`" "`)으로 감싸야 한다.
        - 이스케이프 시퀀스
            - 줄바꿈, 탭 표현 혹은 특수 기호를 표현하기 위해 이스케이프 시퀀스(`\0`, `\n`)를 사용한다.
                
                ```jsx
                let template = '<ul>\n\t<li><a href="#">Home</a></li>\n</ul>'
                
                // 출력 결과
                <ul>
                	<li><li><a href="#">Home</a></li>
                </ul>
                ```
                
            - [이스케이프 시퀀스의 종류](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String#%EC%9D%B4%EC%8A%A4%EC%BC%80%EC%9D%B4%ED%94%84_%ED%91%9C%ED%98%84)
                
                
                | 코드 | 출력 |
                | --- | --- |
                | \0 | NULL 문자 |
                | \' | 작은따옴표 |
                | \" | 큰따옴표 |
                | \\ | 역슬래시 |
                | \n | 개행 |
                | \r | 캐리지 리턴 |
                | \v | 세로 탭 |
                | \t | 탭 |
                | \b | 백 스페이스 |
                | \f | 폼 피드 |
                | \uXXXX | 유니코드 코드포인트 |
                | \u{X} ... \u{XXXXXX} | 유니코드 코드포인트 Experimental |
                | \xXX | Latin-1 문자 |
                | \XXX | 8진수 Latin-1 문자 |
    - ES6 버전에서 **템플릿 리터럴 표기법**이 도입되었다.
        - **템플릿 리터럴 표기법**은 문자열을 **백틱**(`` ``)으로 감싸야 한다.
        - **템플릿 리터럴 표기법 : 멀티라인 문자열**
            - 줄바꿈, 탭 등의 표현이 이스케이프 시퀀스가 없어도 그대로 적용된다.
                
                ```jsx
                let template = `<ul>
                	<li><a href="#">Home</a></li>
                </ul>`;
                
                // 출력 결과
                <ul>
                	<li><li><a href="#">Home</a></li>
                </ul>
                ```
                
        - **템플릿 리터럴 표기법 : 표현식 삽입**
            - 작성한 문자열 내에 표현식을 삽입할 수 있다.
                
                단, 문은 삽입할 수 없다.
                
                ```jsx
                let first = 'Eng';
                let last = 'sheet';
                
                // 기존 방식
                console.log('My nickname is ' + first + last + '.')
                
                // 템플릿 리터럴 방식
                console.log(`My nickname is ${first}${last}.`)
                ```
                
            - 표현식의 평가 결과가 문자열이 아니더라도 타입이 강제로 문자열로 변환된 후 삽입된다.
                
                ```jsx
                console.log(`1 + 2 = ${1 + 2}`) // "1 + 2 = 3"
                ```
                
            - 템플릿 리터럴 표기법이 아닌 일반 문자열에 삽입한 표현식은 문자열로 취급된다.
                
                ```jsx
                console.log('1 + 2 = ${1 + 2}') // "1 + 2 = ${1 + 2}"
                ```
                
4. **불리언 타입** (**Boolean)**
    - 논리적 참(`true`)과 거짓(`false`)를 나타낸다.
5. **undefined 타입**
    - 자바스크립트 엔진이 변수를 초기화 할 때 사용하는 값이다.
    - 변수를 참조했을 때 `undefined`가 반환되었다면 변수가 선언된 후 값이 할당되지 않았음을 의미한다.
    - 개발자가 변수에 직접 `undefined` 를 할당한다면 혼란이 줄 수 있기 때문에 `null` 을 할당해야 한다.
6. **null 타입**
    - 명시적으로 값을 비워두거나 이전 값에 대한 참조를 제거할 때 사용한다.
    - 자바스크립트는 대소문자를 구분하기 때문에 `Null`, `NULL` 등과 구분된다.
    - 함수가 유효한 값을 반환할 수 없는 경우에 `null` 을 반환하기도 한다.
        - HTML 요소를 검색해 반환하는 `document.querySelector` 의 경우 에러 대신 `null` 을 반환한다.
    - `typeof` 명령으로 데이터 유형을 확인했을 때, `object` 로 표시되는 오류가 있다.
7. **심볼 타입 (Symbol)**
    - 다른 객체와 충돌할 위험이 없도록 고유한 식별자(unique identifier)를 만들기 위해 사용한다.
        - 다른 타입의 값은 리터럴을 통해 생성되지만 심벌은 Symbol 함수를 호출하여 생성한다.
        - 비교 연산자를 사용했을 때, 같은 데이터라도 고유하기 때문에 false 반환한다.
        - 거의 사용되지 않는 데이터 유형이지만, 라이브러리 개발자들이 사용하기도 한다.
            
            ```jsx
            let a = Symbol('a');
            let b = Symbol('a');
            
            a === b // false
            ```
            
8. **객체 타입 (Object)**
    1. **배열 (Array)**
    2. **함수 (function)**

---

## 데이터 타입 확인

- `typeof *data*` : 인수의 자료형을 반환하는 연산자이다.
    - 변수의 자료형을 빠르게 알아내고 싶을 때 사용한다.
    - 자료형에 따라 처리 방식을 다르게 할 때 사용한다.
- 연산자 형태와 함수 형태 2가지의 문법 지원을 지원한다.
    
    ```jsx
    let hello = '안녕';
    
    // 연산자 형태
    typeof hello; // string
    
    // 함수 형태
    typeof(hello); // string
    ```
    
- 데이터 유형을 확인하다 보면 특이하거나 오류처럼 보이는 케이스가 몇 가지 존재한다.
    1. `Math` 는 수학 연산을 제공하는 내장 객체이기 때문에 `object` 가 출력된다.
        
        ```jsx
        // 내장 객체 Math의 타입
        typeof Math; // object
        ```
        
    2. `typeof null;` 의 결과는 `null` 이어야 한다.
        
        하지만 실제로는 `null` 이 아닌 `object` 가 결과로 출력되는데,
        
        아주 오래전에 만들어진 잘못된 규칙이지만 하위 호환성을 고려하여 현재까지 변경되지 않았다.
        
        ```jsx
        // null 의 타입이 'object'로 표시되는 문제
        typeof null; // object
        ```
        
    3. `function` 은 객체이며 function 타입이라는 데이터 유형은 존재하지 않는다.
        
        따라서 `typeof Array;` 와 `typeof alert;` 의 결과는 `object` 가 출력되어야 한다.
        
        다만, 위의 `null` 오류와 마찬가지로 하위 호환성을 고려하여 변경되지 않았다.
        
        ```jsx
        // 3. Array, alert 함수의 타입이 'function'으로 표시되는 문제
        typeof Array; // function
        typeof alert; // function
        ```
        

---

## **동적 타입 언어**

자바스크립트는 어떤 데이터 타입의 값이라도 자유롭게 할당 가능한 동적 타입 언어이다.
동적 타입 언어는 데이터 타입에 크게 신경 쓸 필요가 없기 때문에 편리하게 느껴질 수 있다.
하지만 동적 타입 언어는 어쩌면 치명적일 수도 있는 구조적인 단점이 몇 가지 존재한다.

첫 번째 단점은 복잡한 프로그램에서 변화하는 변수 값을 추적하기 어렵다는 것이다.
데이터 타입이 고정되어 있지 않은 변수는 값의 변경에 의해 타입도 언제든지 변경될 수 있어,
값을 직접 확인하기 전에는 타입을 확신할 수 없기 때문이다.

두 번째 단점은 자바스크립트 엔진이 개발자가 의도하지 않은 타입으로 변환 시킨다는 것이다.
즉, 숫자 타입이라고 생각했던 변수가 사실 문자열 타입의 변수일 수도 있다는 말이다.
잘못된 타입을 가진 변수는 작성된 프로그램에서 당연하게도 오류를 출력하게 될 것이다.

한 마디로 동적 타입 언어는 유연성이 높다는 장점이 있지만, 신뢰성이 떨어진다는 단점이 있다.
동적 타입 언어인 자바스크립트를 사용하는 개발자는 변수를 사용할 때 다음 사항들에 주의해야 한다.

1️⃣ 변수는 많을 수록 예측하기 어려우므로, 필요한 경우에 한해 제한적으로 사용한다.
2️⃣ 변수의 유효 범위(스코프)는 최대한 좁게 만들어 변수의 부작용을 억제한다.
3️⃣ 전역 변수는 어디서든 참조/변경이 가능하기 때문에 변경 가능성이 높으므로 사용하지 않는다.
(전역 변수는 프로그램의 복잡성을 증가시키고, 오류의 원인을 추적하기 어렵게 하기도 한다.)
4️⃣ 변수를 할당할 때 상수를 사용하여 값의 변경을 억제한다.
5️⃣ 변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍한다.

<br/>

<aside>

❓ **JavaScript 단점을 보완하는 TypeScript**

위에서 언급했듯 동적 타입 언어는 데이터 타입에 의한 에러 발생 가능성이 높다.
실제로 거대한 규모의 프로젝트에서 의존성이 있는 모듈을 변경했을 때,
다른 모듈에서 에러가 발생하는지 개발 도중에는 확인하기가 매우 힘들다.

TypeScript는 이러한 javaScript의 단점을 명시적 타입 지정으로 보완하면서 등장하게 되었다.
각 변수에 명시적으로 타입을 지정하면서, 타입과 관련된 에러가 발생하는 것을 방지해준다.
최근에는 TypeScript를 사용해서 코드를 작성한 후, JavaScript로 변환하는 경우가 많아졌다.

```jsx
// 동적 형 지정 언어 (JavaScript)
var total = 1568;
var current = 10;
var message = '메세지';
var show = false;

// 정적 형 지정 언어 (TypeScript)
var total:number = 1568;
var current:number = 10;
var message:string = '메세지';
var show:boolean = false;
```

</aside>
<br/>

## 🤔궁금한 점

## 📌중요한 점
