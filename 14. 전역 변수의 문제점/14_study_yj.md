## 목차

[📗배운 점 ](#📗배운-점)

[🤔궁금한 점](#🤔궁금한-점)

[📌중요한 점](#📌중요한-점)

## 📗배운 점

## 14.1 변수의 생명 주기

변수 선언은 코드가 한 줄씩 순차적으로 실행되는 시점인 런타임에 실행되는 것이 아니라 런타임 이전 단계에서 자바스크립트 엔진에 의해 먼저 실행 → 전역 변수에 한정

지역 변수의 생명 주기

```javascript
function foo() {
  var x = "local";
  console.log(x); // local
  return x;
}

foo();
console.log(x); // ReferenceError: x is not defined
```

- foo 함수를 호출하면 함수 몸체의 다른 문들이 순차적으로 시작되기 이전에 x 변수의 선언문이 자바스크립트 엔진에 의해 가장 먼저 실행되어 x 변수가 선언되고 undefined로 초기화
- 그 후, 함수 몸체를 구성하는 문들이 순차적으로 실행되기 시작하고 변수 할당문이 실행되면 x 변수에 값이 할당
- 함수가 종료되면 x 변수도 소멸되어 생명 주기가 종료
- 따라서 함수 내부에서 선언된 지역 변수 x는 foo 함수가 호출되어 실행되는 동안에만 유효
- **지역 변수의 생명 주기는 함수의 생명 주기와 일치**

```javascript
var x = "global";

function foo() {
  console.log(x); // undefined
  var x = "local";
}

foo();
console.log(x); // global
```

- 호이스팅은 스코프를 단위로 동작
  - 전역 변수의 호이스팅은 전역 변수의 선언이 전역 스코프의 선두로 끌어올려진 것처럼 동작
  - 지역 변수의 호이스팅은 지역 변수의 선언이 지역 스코프의 선두로 끌어올려진 것처럼 동작

전역 변수의 생명 주기

전역 코드에는 반환문을 사용할 수 없으므로 마지막 문이 실행되어 더 이상 실행할 문이 없을 때 종료

var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 됨  
**var 키워드로 선언한 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치**

![image](https://github.com/jin62413/js-deepdive-study/assets/71061884/75fb5482-fc99-4533-84b9-34b2187d891f)

## 14.2 전역 변수의 문제점

- 암묵적 결합
  - 전역 변수를 선언하면 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합을 허용
- 긴 생명 주기
  - 전역 변수는 생명 주기가 긺
  - 메모리 리소스를 오랜 기간 소비
  - var 키워드는 변수의 중복 선언을 허용 → 생명 주기가 긴 전역 변수는 변수 이름이 중복될 가능성이 있음
- 스코포 체인 상에서 종점에 존재
  - 전역 변수의 검색 속도가 가장 느림
- 네임스페이스 오염
  - 자바스크립트는 파일이 분리되어 있어도 하나의 전역 스코프를 공유
  - 다른 파일 내에서 동일한 이름으로 명명된 전역 변수나 전역 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있음
  - (네임스페이스 : 개체를 구분할 수 있는 범위를 나타내는 말로 일반적으로 하나의 이름 공간에서는 하나의 이름이 단 하나의 개체만을 가리키게 됨)

## 14.3 전역 변수의 사용을 억제하는 방법

변수의 스코프는 좁을수록 좋음

- 즉시 실행 함수
  - 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 됨

```javascript
(function () {
  var foo = 10; // 즉시 실행 함수의 지역 변수
  // ...
})();

console.log(foo); // ReferenceError: foo is not defined
```

- 네임스페이스 객체
  - 전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법
  - 네임 스페이스 객체 자체가 전역 변수에 할당되므로 그다지 유용하지 않음

```javascript
var MYAPP = {}; // 전역 네임스페이스 객체

MYAPP.person = {
  name: "Lee",
  address: "Seoul",
};

console.log(MYAPP.person.name); // Lee
```

- 모듈 패턴
  - 클래스를 모방해서 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만듦
  - 전역 변수의 억제는 물론 캡슐화까지 구현할 수 있음
    - 캡슐화 : 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 찹조하고 조작할 수 있는 동작인 메서드를 하나로 묶는 것
  - 클로저를 기반으로 동작
  - 정보 은닉을 구현하기 위해 사용

```javascript
var Counter = (function () {
  // private 변수
  var num = 0;

  // 외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환한다.
  return {
    increase() {
      return ++num;
    },
    decrease() {
      return --num;
    },
  };
})();

// private 변수는 외부로 노출되지 않는다.
console.log(Counter.num); // undefined

console.log(Counter.increase()); // 1
console.log(Counter.increase()); // 2
console.log(Counter.decrease()); // 1
console.log(Counter.decrease()); // 0
```

## 🤔궁금한 점

## 📌중요한 점

지역 변수의 생명 주기는 함수의 생명 주기와 일치

전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치

호이스팅은 스코프를 단위로 동작

전역 변수를 억제하는 법

1. 즉시 실행 함수
2. 네임스페이스 객체
3. 모듈 패턴(캡슐화)
