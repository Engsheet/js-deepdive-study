bbㅠbb## 목차

- [11 원시값과 객체의 비교](#11-원시값과-객체의-비교)
  - [11.1 원시값](#111-원시값)
    - [11.1.1 변경이 불가능 한 값](#1111-변경이-불가능-한-값)
    - [11.1.2 문자열과 불변성](#1112-문자열과-불변성)
    - [11.1.3 값에 의한 전달](#1113-값에-의한-전달)
  - [11.2 객체](#112-객체)
    - [11.2.1 변경 가능한 값](#1121-변경-가능한-값)
    - [11.2.2 참조에 의한 전달](#1122-참조에-의한-전달)

[📗배운 점 ](#📗배운-점)

[🤔궁금한 점](#🤔궁금한-점)

[📌중요한 점](#📌중요한-점)

## 📗배운 점

### 11 원시값과 객체의 비교

> 원시 타입의 값, 즉 원시값은 변경이 불가능한값으로 변수에 할당하면 실제 값이 저장된다.

> 객체 타입의 값, 즉 객체는 변경이 가능한 값으로 변수에 할당하면 참조 값이 저장된다.

#### 11.1 원시값

**값**은 변경 불가능 한 값. (읽기 전용 값으로 변경이 불가능 하다.)
![image](https://github.com/chowonn/js-deepdive-study/assets/74224516/08b72e61-d3b7-471a-941c-95daf5da9de6){: width="900" }
원시 값은 절대 변경 불가능 하다.값을 변경하는게 아니라 재할당 하는 것이다.
변수에 새로운 값을 재할당 하는 경우, 새로운 메모리 공간을 확보하고 재할당 한 값을 저장 한 후
변수가 참조하던 메모리 공간의 주소를 변경한다.
값의 이러한 특성을 **불변성** 이라 한다.

불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수값을 변경할 수 있는 방법이 없다.
만약 재할당 이외에 원시 값인 변수 값을 변경할 수 있다면 예기치 않게 변수 값이 변경될 수 있다는 것을 의미한다.

원시값을 저장하려면 먼저 확보해야 하는 메모리 공간의 크기를 결정해야 한다.
이를 위해 원시타입별로 메모리 공간의 크기가 미리 정해져 있다.

> Boolean : 1byte</br>Number: 8byte</br>String: 각문자별 2byte, 문자열은 길이에 비례한다.</br>null과 undefined : 공식적으로 정의되지않음. 매우 작다.</br>Symbol: 심볼의 설명에 따라 다르다 심볼의 설명은 문자열이다.

예를 들어본다면

```javascript
var str = "Hello";
str = "world";
```

첫 번째 문이 실행 되면 문자열 `'Hello'`가 생성되고 식별자 str은 문자열`'Hello'`첫 번째 셀 주소를 가리킨다.
그리고 두번째 문이 실행되면 새로운 문자열 `'world'`를 메모리에 생성하고 str은 이것을 가리킨다.

```javascript
var str = "string";

// 문자열은 유사 배열이므로 배열과 유사하게 인덱스를 사용해 각 문자에 접근할 수 있다.
// 하지만 문자열은 원시값이므로 변경할 수 없다. 이때 에러가 발생하지 않는다.
str[0] = "S";

console.log(str); // string
```

`str[0] = 'S'`처럼 이미 생성된 문자열의 일부를 변경해도,
문자열은 변경이 불가능 한 `값`이기 때문에 반영되지 않는다.
그러나 변수에 새로운 문자열을 재할당 하는것은 가능하다. 이것은 변경이 아니라 재할당이기 때문이다.

숫자도 위와 같은 규칙을 따른다.

```javascript
/*초기화*/
var score = 80;

/*복사 or 참조*/
// copy 변수에는 score 변수의 값 80이 복사되어 할당된다.
var copy = score;

console.log(score, copy); // 80  80
console.log(score === copy); // true

/*재할당*/
// score 변수와 copy 변수의 값은 다른 메모리 공간에 저장된 별개의 값이다.
// 따라서 score 변수의 값을 변경해도 copy 변수의 값에는 어떠한 영향도 주지 않는다.
score = 100;

console.log(score, copy); // 100  80
console.log(score === copy); // false
```

![image](https://github.com/chowonn/js-deepdive-study/assets/74224516/1414522b-5686-451e-babf-bde8211be81e){: width="1000" height="340"}
왼쪽부터 순서대로 `초기화`, `복사`, `참조`, `재할당`의 내용을 보면 된다.
`score` 를 초기화 하면 메모리에 할당이 되고
`copy = score;` 값을 복사하는지 값을 참조하는지는 자바스크립트 엔진을 구현하는 제조사에 따라 다를 수 있다.
`score = 100;` 으로 재할당 하는 순간 `score`만 변경이 되기 때문에 서로 다른 값을 참조하게 된다.

엄격하게 표현하면 변수에는 값이 전달되는것이 아니라
메모리 주소가 전달되는것이다.
이는 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있기 때문이다.

### 11.2 객체

객체는 프로퍼티의 개수가 정해져 있지 않으며, 동적으로 추가되고 삭제할 수 있다.
또한 프로퍼티 값에도 제약이 없다.
└ 따라서 객체는 확보해야할 메모리 공간의 크기를 사전에 정해둘 수 없다.

변수에 객체를 할당하면 객체를 할당한 변수가 기억하는 메모리 주소를 통해
메모리 공간에 접근하여 참조 값에 접근 할 수 있다.

객체는 원시값과 다르게 재할당 없이 직접 변경이 가능하다.
또한 프로퍼티를 동적으로 추가할수도 있고 프로퍼티 자체를 삭제할 수도 있다.
![image](https://github.com/chowonn/js-deepdive-study/assets/74224516/7d336f2c-58c0-44ec-9966-11f89e65b436){: width="300" height="300"}

객체는 이러한 구조적 단점에 따른 부작용이 있는데 여러개의 식별자가 하나의 객체를 공유할 수 있다는 것이다.
`깊은 복사`와 `얕은 복사`

```javascript
var person = {
  name: "Lee",
};

// 참조값을 복사(얕은 복사)
var copy = person;
```

![image](https://github.com/chowonn/js-deepdive-study/assets/74224516/dedb427d-cb51-4a26-8d96-897ac01d3eec){: width="700" height="340"}

원본 `person`을 사본`copy`에 할당하면 원본의 `person`의 참조값을 복사해서 `copy`에 저장한다.이때 원본과 사본은 저장된 메모리 주소는 다르지만 동일한 참조값을 갖는다.

## 🤔궁금한 점

## 📌중요한 점
